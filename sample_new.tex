%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document



% The following packages can be found on http:\\www.ctan.org
\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{caption}
\usepackage{subcaption}
\usepackage{epsfig} % for postscript graphics files
\usepackage{mathptmx} % assumes new font selection scheme installed
\usepackage{times} % assumes new font selection scheme installed
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed

\title{\LARGE \bf
Interception of moving objects with a robotic arm in a simulated environment
}

\author{Juan Garcia, Harrison Jones and Arash Rouhani*
  \thanks{\texttt{*\{jgarcia39,harrisonhjones,rarash\}@gatech.edu}}
}


\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

The problem of catching a moving object can be divided into two sub problems:
first the obeject must be perceived and its path must be estimatated so
movements can be calculated that would result in successfully catching the
object in the future. The second sub problem is, once a future path has been
estimated, to find a catching configuration. This paper focuses primarily on
the second problem of finding an acceptable configuration. Simple models which
simulate sensor inaccuracy and randomness are used to closely simulate real
environments and  regression models are used to estimate the objects path in
these simulated real environments. Because  multiple end configurations are
acceptable if the goal is simply to catch the object, a multi-goal RRT, a
modified version of Rapidly-exploring Random Trees (RRTs) which grows towards
multiple goals simultaneously, was implemented in an attempt to have the RRT
grow toward several predicted path nodes. The multi-goal RRT was compared
against a regular RRT and was found to be inferior to regular RRTs in most
cases

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

\subsection{Motivation}

The motivation for this project came from two sources. One is a video which
illustrates a robot capable of "catching" a piece of trash thrown using a
vision system and limited path planning. The little trash robot is pretty
interesting, and useful, and initially the thought of expanding on the idea was
toyed with. The other source of motivation came from a previous piece of work
performed under Professor Mike Stillman at Georgia Tech. Previously a group
under Stillman had worked on an algorithm which blocked known sword path,s in a
simulated environment. The group had not explored the idea of predicting a
sword swing given the current path of the sword.

\subsection{Problem}

These two interesting ideas were combined into a "general purpose" problem
which covered both motivating sources. The problem therefore tackled in this
project is how to intercept a moving object using a robot arm in a noisy
simulated environment given limited information on that path of the object.
This problem is interesting because it is fairly general purpose covers a great
number of practical applications such as catching balls, blocking punches,
military applications, etc.

\subsection{Solution}

The solution described in this paper utilizes an algorithm which tracks the
objects, predicts its future path, and then moves a virtual robot arm to
intercept the object. This is done by using two different prediction
algorithms, a linear predictor, used for punching, handshakes, etc, and a
quadratic predictor, used for projectile objects such as trash or balls. After
computing a predicted path a multi-goal RRT is used to move the robot arm to
intercept the object while still avoiding obstacles in its environment.



\section{RELATED WORK}

An extension of RRTs for multi goal purposes is introduced here. There are also
other approaches to solving multi-goal motion planning (add referencess). As
for the modeling of the projectile motion, nothing is used from academia.

\section{METHODS}

We'll cover the methods in the order they are used in a complete simulation.
First, we must generate a projectile path, then distortion is applied. In order
to know where it's possible to catch the object some path prediction is used.
Then to actually get a series of possible robot stances, inverse kinematics is
applied to get some corresponding joint configuration for each projectile
position. Finally, and most highlighted part in this paper, we search for the
easiest to reach joint space configuration. It should be noted that this whole
process is done iteratively, at fixed time steps we replan taking in account
the most recent observation of the projectile.

\subsection{Path Projection}

We create a path by sampling positions from the basic formula for projectile motion:

\[
  \vec{x}(t) = \vec{x}_0 + \vec{v}t + {\vec{a}t^2 \over 2}
\]

Where the arrow notation denotes a variable being a vector in the
workspace.  This simple equation covers most of the motions in our
application except for wind resistance. Note that by setting the
acceleration to $\vec{0}$ the projectile will be a straight line
resembling a straight punch. By setting $\vec{a} = -\vec{g}$ where
$\vec{g}$ is a gravity constant we get a standard "shoot from canon"
projectile motion. Wind is simulated by adding a random constant to
the acceleration.

\subsubsection{Deciding $\vec{x}$, $\vec{v}$, $\vec{a}$}

We just saw how changing the acceleration we'll get simple models of
different behaviors that is desired to have in our intended application.
However, in all cases we must make sure that it will be possible at all
to catch the thrown object, in other words, the trajectory must
intersect the set of reachable points of the arm. To ensure that we
introduce two new points, a \emph{random start position}, that simply is
$\vec{x}_0$ and a \emph{random reachable position} which is a random
point reachable by the robot arm. With these approach in mind one can
solve for the velocity if we fix the acceleration. To simplify further
and decrease the solution space we set that the velocity to have an
angle of 45 degrees from the floor plane. For the wind to actually have
a negative impact, we let the calculations of the velocity be obvlivious
of it.

\subsubsection{Distortion}

Since in later steps of the iteration the robot is going to predict the
remaining path, we must add distortion to it to make it impossible to
retrieve the whole original exact path again. It's hard to motivate
any model besides simple randomness here.

\[
  \vec{x}_{observed}(t) = \vec{x}(t) + noise
\]

Where for each discrete time step in our simulation the $noise$ is a vector
where each coordinate is a uniform distribution in $[-\mu, \mu]$

\subsection{Path Prediction}

Given some sample points, we work backwards from the equations in the
model for path projection.  We have two prediction models, one assumes
straight motion and the other projectile motion.  The equation

\[
  \vec{x}_{observed}(t) = \vec{x}_0 + \vec{v}t + {\vec{a}t^2 \over 2}
\]

will cover both cases, only that you set $a=0$ in the linear version.
However, only two and three data points are required to solve this
system for the linear and quadratic version respectively, to fix that we
simply only look at the most recent data points we require.

Note that this is of course not exact as  it does not compensate for the
unknown noise, to compensate for the noise, one can treat a chunk of
points  as one point by taking their average. Note that with this
strategy we still need more points for the quadratic version. If the
chunk sizes are to small, we won't defeat noise and if it's too small we
won't be able to estimate the trajectory, as we must wait until we have
enough points to create the chunks. Therfor a dynamic chunk size was
chosen that grows with number of data points. A cap was set on the chunk
size to avoid looking at too old and outdated data.

We found both the working backwards from the equations prediction and
the idea of chunking the data to be the simplest to implement and choose
that over more sophisticated regression.

\subsection{Inverse kinematics}

Knowing the trajectory, one can use inverse kinematics to find a corresponding
joint space configuration. We do use the pseudo inverse jacobian method.
That is to simply iterate

\[
  \Delta q = \mathbf{J}^{+} \Delta x
\]

until convergence where $\mathbf{J}^{+} =
\mathbf{J}^T(\mathbf{J}\mathbf{J}^T)^{-1}$.


\subsection{Planning}

We plan with either one of the two algorithms, the regular RRT
\cite{lavalle2001randomized} and the
multi-goal RRT that is introduced in this paper. Which of the two we use
will depend on the parameters we set before we start a single
simulation.

\subsubsection{Multi-goal RRT}

The multi goal RRT is working very much like the traditional one with
the exception that there are multiple goals and reaching any one of them
is considered a success. One might think of two different strategies for
the multi goal rrt. The first being that you return the first path that
leads to any of the goals and the second strategy is to make sure you've
got a path for each goal and then return the shortest. The first one is
always faster because it don't need to grow the tree until each goal has
been reached. Since it also was simpler to implement we went with a
multi goal rrt using the first strategy.

What differs between a regular rrt and any of the two multi goal rrts
kinds is only the termination condition. The single rrt continues to
grow until the goal has been reached, the first strategy of the multi
goal keeps growing until \emph{any} goal has been reached while the
other strategy keeps growing the tree until \emph{all} goals have been
reached.

As for the concepts of greedy, connect and bidirectional, only greedy and the
connect strategy is applicable to the multi goal rrt. The original greedy
strategy takes the goal and grows towards it\cite{robocup, FergusonKS06}. In
our case we take any of the goals randomly and grow towards it. As for connect
one would imagine growing towards a random configuration and then keep growing
to the same configuration until one collides, just like the original connect
algorithm does\cite{kuffner2000rrt}. We will, however, only use the greedy goal
biasing in both our regular rrt implementation and multi-goal rrt. The reason
for this was to make the behavior easier to reason about than it would be if
multiple features could cause unexpected results.

% We consider the connect strategy to defeat the purpose of the
% multi goal rrt, as if we have an extreme case where there are no objects to
% block the path, connect would just randomly pick any of the goals and keep
% growing to it and the purpose of choosing the goal with the closest distance
% with respect to objects is defeated.

\subsubsection{Arm speed and using the path}



\subsection{Replanning, Discretization and Arm Speed}

Before one iteration is done and we start replanning with the most
recently observed data we move the arm. For the simulation to be
realistic, the  maximum distance the arm can move must be limitied for
each time step. The question is how distance is measured, or rather in
which norm. Most realistically for our application might have been the
infinity norm, which means that all joints are allowed to rotate a fixed
amount of degrees independent of each other. Regardless of that we used
regular euclidean distance, the two norm. The reason is that it was easy
to implement because you can set the step size parameter to the rrt and
interpret the second position it its returned path as the next position
for the arm.

With the joints configured to their now angles, we increase the
simulation time by the fixed $\Delta t$ and keep iterating and replan as
more information of the trajectory gets available when time increases.

\section{EXPERIMENTS}

The experimentation and accompanied development were targeted towards (1)
determining the robustness of the approaches presented to noise sources and (2)
selecting the best combination of predictors and RRT-variants for use in a
future non-simulated setting. The overall approach presented in the previous
sections was tested in the DART/GRIP environment through a developed interface
that allowed for the specification of different amounts of noise, number of
simulations, predictor type, among other parameters.  The results were analyzed
according to the following criteria: (i) success rate given an amount of noise,
(ii) success rate vs. increasing amounts of noise for different combinations of
RRT-variants and predictors, (iii) completion time given an amount of noise.
Success rate was defined as the amount of times the arm was able to intercept
the moving sphere divided by the total number of simulations (i.e. a
percentage). The workspace distance d between the arm’s end-effector and the
moving sphere was repeatedly calculated in order to determine whether an
interception had occurred. If d was less than a given threshold t, then the arm
successfully intercepted the moving sphere. In this case, t was set to the
radius of the sphere (i.e. 0.12).  The graphs shown below summarize the results
of the experiments undertaken. Their connotations and insights will be analyzed
in the following section.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.25\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/noise-005}
                \caption{$\mu = 0.05$}
                \label{fig:noise-005}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc. 
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.2\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/noise-009}
                \caption{$\mu = 0.09$}
                \label{fig:noise-009}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc. 
          %(or a blank line to force the subfigure onto a new line)
        \caption{Success rates for combinations of Multi-Goal RRT, Single-RRT, Linear and Quadratic predictors after 100 simulations having varying noise $\mu$}\label{fig:noise}
\end{figure}


\begin{figure}
        \centering
        \begin{subfigure}[b]{0.22\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/multi}
                \caption{Multi goal RRT}
                \label{fig:multi}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc. 
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.24\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/single}
                \caption{Single goal RRT}
                \label{fig:single}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc. 
          %(or a blank line to force the subfigure onto a new line)
        \caption{Average RRT success rates versus increasing noise
        with Linear Predictor; 10 simulations for each increase in 0.05
      noise}\label{fig:rrts}
\end{figure}

\begin{figure}
        \centering
        \includegraphics[width=3in]{fig/runtimes}
        \caption{Average times for Single-goal and
        Multi-goal RRTs after 100 simulations with both Linear and
      Quadratic predictors where $\mu = 0.05$}\label{fig:runtimes}
\end{figure}

Figure 3. Avg. Multi-Goal RRT success rate vs. increasing noise with Linear Predictor; 10 simulations for each increase in 0.05 noise.




Figure 4. Avg. Single-goal RRT success rate vs. increasing noise with Linear Predictor; 10 simulations for each increase in 0.05 noise.


Figure 5. Avg. completion times for Single-goal and Multi-goal RRTs after 100 simulations with both Linear and Quadratic predictors; noise = 0.05.



Analysis
Figure 1 shows the success rates for combinations of Multi-goal and Single-goal with Linear and Quadratic predictors after 100 simulations with a noise of 0.05. In both cases, the Single-goal approach achieves a higher success rate than the Multi-goal approach. The difference in such success, an average of 3 percent units, is not enough to conclude the dominance of one method over the other for this given noise amount. In addition, the quadratic predictor seems to yield higher success rates when used by both approaches with this noise amount, indicating the better representation of the projectile path by our predicting equations. 
Figure 2, in contrast, showcases a much more interesting scenario. With a noise amount of 0.09, the Multi-goal and Single-goal approaches achieve similar success rates (about 87 percent) when employing the Linear predictor. When the approaches utilize the Quadratic predictors their success rates drop by a combined average of 8 percent units. In this case, the Multi-goal approach achieves a noticeably lower success rate. With a significant increase in sensor noise, the robotic arm’s perceived sphere path does not longer follow projectile motion characteristics as the sphere bounces around. In this case, the Quadratic predictor in a way overfits the model as it uses 3 averaging points to predict a curved motion. The Linear predictor only predicts line trajectories that with a clutter of perceived points yield higher accuracy rates. 

---Add analysis of why Multi does badly with Quadratic---

Figures 3 and 4 depict the performance of both the Single-goal and Multi-goal RRT approaches as the noise amount increases. A Linear predictor was utilized in both cases as previous analysis demonstrated its robustness to sensor noise. For each noise case, the average success rate of 10 simulations was computed. Both approaches’ rates steadily drop as the amount of noise increases, with the Single-goal RRT staying above 90% for noise sources between 0 and 0.1 while the Multi-goal RRT only for value between 0 and 0.05. The similar behavior of both approaches regarding an increase in noise showcases the need to implement better prediction techniques, as the current ones are only naive approaches to tackle such noise and uncertainty scenarios. A more thorough analysis of these approaches’ response in noisy situations would be achieved through known regression and estimation techniques. Time constraints forced these topics to be considered for future work. 
At last, Figure 4 presents the average execution times during 100 simulations of Single-goal and Multi-goal RRTs with Linear predictors. Multi-goal RRTs achieve faster execution times (i.e. 200ms difference) than Single-goal RRTs as the tree growth is biased by all reachable points of the sphere trajectories. When any goal is reached, reaching the rest is not computationally expensive as these points are expected to be mostly close in space and time. Single-goal RRTs in contrast, constantly expands the tree towards the closest point in terms of joint-space distance, thus taking longer to get there. 













Our test environment consisted of a 7 joint robot with only a few
objects around it. All of the objects were on the ground. The object was
always shot from X meters away towards the hand.

In this setting single goal rrt won.

\section{ANALYSIS}

Multi goal rrt might have been changing its mind all the time between each replanning making it distracted.

\section{DISCUSSION}

It would be interesting to test the algorithms in an environment where there
are more objects that the arm can't touch. Also, the multi goal rrt does not
need to stop once it reaches one goal, it could instead keep expanding until it
hits all goals and then pick the one with the shortest path.

As an extra benefit to both rrt planners, path shortening could be applied.


\bibliographystyle{plain}
\bibliography{mybib}

% \begin{thebibliography}{99}

% \bibitem{c1} TODO: Add real references

% \end{thebibliography}




\end{document}
