%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document



% The following packages can be found on http:\\www.ctan.org
%\usepackage{graphics} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
%\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
%\usepackage{amsmath} % assumes amsmath package installed
%\usepackage{amssymb}  % assumes amsmath package installed

\title{\LARGE \bf
Interception of moving objects with a robotic arm in a simulated environment
}

\author{Juan Garcia, Harrison Jones and Arash Rouhani*
  \thanks{\texttt{*\{jgarcia39,harrisonhjones,rarash\}@gatech.edu}}
}


\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

The problem of catching a moving object can be divided into two sub problems: first the obeject must be perceive and its path must be estimatated so movements can be calculated that would result in successfully catching the object in the future. The second sub problem is, once a future path has been estimated, to find a catching configuration. This paper focuses primarily on the second problem of finding an acceptable configuration. Simple models which simulate sensor inaccuracy and randomness are used to closely simulate real environments and  regression models are used to estimate the objects path in these simulated real environments. Because  multiple end configurations are acceptable if the goal is simply to catch the object, a multi-goal RRT, a modified version of Rapidly-exploring Random Trees (RRTs) which grows towards multiple goals simultaneously, was implemented in an attempt to have the RRT grow toward several predicted path nodes. The multi-goal RRT was compared against a regular RRT and was found to be inferior to regular RRTs in most cases

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

\subsection{Motivation}

The motivation for this project came from two sources. One is a video which
illustrates a robot capable of "catching" a piece of trash thrown using a
vision system and limited path planning. The little trash robot is pretty
interesting, and useful, and initially the thought of expanding on the idea was
toyed with. The other source of motivation came from a previous piece of work
performed under Professor Mike Stillman at Georgia Tech. Previously a group
under Stillman had worked on an algorithm which blocked known sword path,s in a
simulated environment. The group had not explored the idea of predicting a
sword swing given the current path of the sword.

\subsection{Problem}

These two interesting ideas were combined into a "general purpose" problem
which covered both motivating sources. The problem therefore tackled in this
project is how to intercept a moving object using a robot arm in a noisy
simulated environment given limited information on that path of the object.
This problem is interesting because it is fairly general purpose covers a great
number of practical applications such as catching balls, blocking punches,
military applications, etc.

\subsection{Solution}

The solution described in this paper utilizes an algorithm which tracks the
objects, predicts its future path, and then moves a virtual robot arm to
intercept the object. This is done by using two different prediction
algorithms, a linear predictor, used for punching, handshakes, etc, and a
quadratic predictor, used for projectile objects such as trash or balls. After
computing a predicted path a multi-goal RRT is used to move the robot arm to
intercept the object while still avoiding obstacles in its environment.



\section{RELATED WORK}

An extension of RRTs for multi goal purposes is introduced here. There are also
other approaches to solving multi-goal motion planning (add referencess). As
for the modeling of the projectile motion, nothing is used from academia.

\section{METHODS}

We'll cover the methods in the order they are used in a complete simulation.
First, we must generate a projectile path, then distortion is applied. In order
to know where it's possible to catch the object some path prediction is used.
Then to actually get a series of possible robot stances, inverse kinematics is
applied to get some corresponding joint configuration for each projectile
position. Finally, and most highlighted part in this paper, we search for the
easiest to reach joint space configuration. It should be noted that this whole
process is done iteratively, at fixed time steps we replan taking in account
the most recent observation of the projectile.

\subsection{Path Projection}

We create a path by sampling positions from the basic formula for projectile motion:

\[
  \vec{x}(t) = \vec{x}_0 + \vec{v}t + {\vec{a}t^2 \over 2}
\]

Where the arrow notation denotes a variable being a vector in the
workspace.  This simple equation covers most of the motions in our
application except for wind resistance. Note that by setting the
acceleration to $\vec{0}$ the projectile will be a straight line
resembling a straight punch. By setting $\vec{a} = -\vec{g}$ where
$\vec{g}$ is a gravity constant we get a standard "shoot from canon"
projectile motion. Wind is simulated by adding a random constant to
the acceleration.

\subsubsection{Deciding $\vec{x}$, $\vec{v}$, $\vec{a}$}

We just saw how changing the acceleration we'll get simple models of
different behaviors that is desired to have in our intended application.
However, in all cases we must make sure that it will be possible at all
to catch the thrown object, in other words, the trajectory must
intersect the set of reachable points of the arm. To ensure that we
introduce two new points, a \emph{random start position}, that simply is
$\vec{x}_0$ and a \emph{random reachable position} which is a random
point reachable by the robot arm. With these approach in mind one can
solve for the velocity if we fix the acceleration. To simplify further
and decrease the solution space we set that the velocity to have an
angle of 45 degrees from the floor plane. For the wind to actually have
a negative impact, we let the calculations of the velocity be obvlivious
of it.

\subsubsection{Distortion}

Since in later steps of the iteration the robot is going to predict the
remaining path, we must add distortion to it to make it impossible to
retrieve the whole original exact path again. It's hard to motivate
any model besides simple randomness here.

\[
  \vec{x}_{observed}(t) = \vec{x}(t) + noise
\]

Where for each discrete time step in our simulation the $noise$ is a vector
where each coordinate is a uniform distribution in $[-\mu, \mu]$

\subsection{Path Prediction}

Given some sample points, we work backwards from the equations in the
model for path projection.  We have two prediction models, one assumes
straight motion and the other projectile motion.  The equation

\[
  \vec{x}_{observed}(t) = \vec{x}_0 + \vec{v}t + {\vec{a}t^2 \over 2}
\]

will cover both cases, only that you set $a=0$ in the linear version.
However, only two and three data points are required to solve this
system for the linear and quadratic version respectively, to fix that we
simply only look at the most recent data points we require.

Note that this is of course not exact as  it does not compensate for the
unknown noise, to compensate for the noise, one can treat a chunk of
points  as one point by taking their average. Note that with this
strategy we still need more points for the quadratic version. If the
chunk sizes are to small, we won't defeat noise and if it's too small we
won't be able to estimate the trajectory, as we must wait until we have
enough points to create the chunks. Therfor a dynamic chunk size was
chosen that grows with number of data points. A cap was set on the chunk
size to avoid looking at too old and outdated data.

We found both the working backwards from the equations prediction and
the idea of chunking the data to be the simplest to implement and choose
that over more sophisticated regression.

\subsection{Inverse kinematics}

Knowing the trajectory, one can use inverse kinematics to find a corresponding
joint space configuration. We do use the pseudo inverse jacobian method.
That is to simply iterate

\[
  \Delta q = \mathbf{J}^{+} \Delta x
\]

until convergence where $\mathbf{J}^{+} =
\mathbf{J}^T(\mathbf{J}\mathbf{J}^T)^{-1}$.


\subsection{Planning}

We plan with either one of the two algorithms, the regular RRT
and the
multi-goal RRT that is introduced in this paper. Which of the two we use
will depend on the parameters we set before we start a single
simulation.

\subsubsection{Traditional RRT}

We defined distance as the infinity norm.

\subsubsection{Multi-goal RRT}

The multi goal RRT is working very much like the traditional one with
the exception that there are multiple goals and reaching any one of them
is considered a success. One might think of two different strategies for
the multi goal rrt. The first being that you return the first path that
leads to any of the goals and the second strategy is to make sure you've
got a path for each goal and then return the shortest. The first one is
always faster because it don't need to grow the tree until each goal has
been reached. Since it also was simpler to implement we went with a
multi goal rrt using the first strategy.

What differs between a regular rrt and any of the two multi goal rrts
kinds is only the termination condition. The single rrt continues to
grow until the goal has been reached, the first strategy of the multi
goal keeps growing until \emph{any} goal has been reached while the
other strategy keeps growing the tree until \emph{all} goals have been
reached.

As for the concepts of greedy, connect and bidirectional, only greedy
and the connect strategy is applicable to the multi goal rrt. The
original greedy strategy takes the goal and grows towards it. In our
case we take any of the goals randomly and grow towards
it\cite{rrt-greedy}. As for connect one would imagine growing towards a
random configuration keep iterating towards, just like the original
does\cite{kuffner2000rrt}.  takes the goal and grows towards i

We consider the connect strategy to defeat the purpose of the
multi goal rrt, as if we have an extreme case where there are no objects to
block the path, connect would just randomly pick any of the goals and keep
growing to it and the purpose of choosing the goal with the closest distance
with respect to objects is defeated.

\subsection{Replanning}

With a fixed $\Delta t$ we keep iterating and do replanning as more information
of the trajectory gets available all the time.

\section{EXPERIMENTS}

Our test environment consisted of a 7 joint robot with only a few
objects around it. All of the objects were on the ground. The object was
always shot from X meters away towards the hand.

In this setting single goal rrt won.

\section{ANALYSIS}

Multi goal rrt might have been changing its mind all the time between each replanning making it distracted.

\section{DISCUSSION}

It would be interesting to test the algorithms in an environment where there
are more objects that the arm can't touch. Also, the multi goal rrt does not
need to stop once it reaches one goal, it could instead keep expanding until it
hits all goals and then pick the one with the shortest path.

As an extra benefit to both rrt planners, path shortening could be applied.


\bibliographystyle{plain}
\bibliography{mybib}

% \begin{thebibliography}{99}

% \bibitem{c1} TODO: Add real references

% \end{thebibliography}




\end{document}
